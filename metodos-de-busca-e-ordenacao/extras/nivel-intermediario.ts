/**
 * EXERC√çCIOS EXTRAS - N√çVEL INTERMEDI√ÅRIO üü°
 * Algoritmos mais eficientes e t√©cnicas avan√ßadas de busca e ordena√ß√£o
 */

/**
 * FUN√á√ïES AUXILIARES MATEM√ÅTICAS
 * Implementa√ß√µes manuais para compatibilidade
 */
class MathUtils {
    /**
     * Logaritmo base 2 implementado manualmente
     */
    static log2(n: number): number {
        if (n <= 0) return -Infinity;
        if (n === 1) return 0;
        
        let resultado = 0;
        let temp = n;
        
        // Usando logaritmo natural: log2(n) = ln(n) / ln(2)
        // Implementa√ß√£o aproximada do logaritmo natural
        while (temp > 1) {
            temp = temp / 2;
            resultado++;
        }
        
        // Refinamento para maior precis√£o
        if (temp > 0.5) {
            resultado += temp;
        }
        
        return resultado;
    }
    
    /**
     * Math.ceil implementado manualmente
     */
    static ceil(n: number): number {
        const intPart = Math.floor(n);
        return (n > intPart) ? intPart + 1 : intPart;
    }
    
    /**
     * Math.round implementado manualmente
     */
    static round(n: number): number {
        return Math.floor(n + 0.5);
    }
    
    /**
     * Repetir string implementado manualmente
     */
    static repeat(str: string, count: number): string {
        let resultado = "";
        for (let i = 0; i < count; i++) {
            resultado += str;
        }
        return resultado;
    }
}

/**
 * EXERC√çCIO EXTRA 4: MERGE SORT EDUCATIVO
 * Algoritmo "Dividir para Conquistar" - O(n log n)
 * Um dos algoritmos mais importantes da computa√ß√£o!
 */
class MergeSortEducativo {
    
    /**
     * Merge Sort principal com visualiza√ß√£o completa
     * CONCEITO: Divide o array ao meio at√© ter elementos √∫nicos, depois mescla ordenadamente
     * COMPLEXIDADE: O(n log n) - muito melhor que O(n¬≤)!
     */
    static ordenar(array: number[], nivel: number = 0): number[] {
        const indentacao = MathUtils.repeat("  ", nivel);
        
        console.log(`${indentacao}üî∏ DIVIS√ÉO n√≠vel ${nivel}: [${array.join(', ')}]`);
        
        // CASO BASE: Se o array tem 1 ou 0 elementos, j√° est√° ordenado
        if (array.length <= 1) {
            console.log(`${indentacao}   ‚úÖ Caso base: array com ${array.length} elemento(s)`);
            return array;
        }
        
        // DIVIS√ÉO: Divide o array ao meio
        const meio = Math.floor(array.length / 2);
        const esquerda = array.slice(0, meio);
        const direita = array.slice(meio);
        
        console.log(`${indentacao}   ‚ÜôÔ∏è  Esquerda: [${esquerda.join(', ')}]`);
        console.log(`${indentacao}   ‚ÜòÔ∏è  Direita: [${direita.join(', ')}]`);
        
        // CONQUISTA: Ordena recursivamente cada metade
        const esquerdaOrdenada = this.ordenar(esquerda, nivel + 1);
        const direitaOrdenada = this.ordenar(direita, nivel + 1);
        
        // COMBINA√á√ÉO: Mescla as duas metades ordenadas
        const resultado = this.mesclar(esquerdaOrdenada, direitaOrdenada, nivel);
        
        console.log(`${indentacao}üîπ RESULTADO n√≠vel ${nivel}: [${resultado.join(', ')}]`);
        return resultado;
    }
    
    /**
     * Mescla duas arrays ordenadas em uma array ordenada
     * ESTA √â A PARTE M√ÅGICA DO MERGE SORT!
     */
    private static mesclar(esquerda: number[], direita: number[], nivel: number): number[] {
        const indentacao = MathUtils.repeat("  ", nivel);
        const resultado: number[] = [];
        let i = 0, j = 0;
        
        console.log(`${indentacao}   üîÄ MESCLANDO: [${esquerda.join(', ')}] + [${direita.join(', ')}]`);
        
        // Compara elemento por elemento e pega o menor
        while (i < esquerda.length && j < direita.length) {
            if (esquerda[i] <= direita[j]) {
                resultado.push(esquerda[i]);
                console.log(`${indentacao}      ${esquerda[i]} ‚â§ ${direita[j]} ‚Üí pegando ${esquerda[i]}`);
                i++;
            } else {
                resultado.push(direita[j]);
                console.log(`${indentacao}      ${esquerda[i]} > ${direita[j]} ‚Üí pegando ${direita[j]}`);
                j++;
            }
        }
        
        // Adiciona elementos restantes (se houver)
        while (i < esquerda.length) {
            resultado.push(esquerda[i]);
            console.log(`${indentacao}      Restante da esquerda: ${esquerda[i]}`);
            i++;
        }
        
        while (j < direita.length) {
            resultado.push(direita[j]);
            console.log(`${indentacao}      Restante da direita: ${direita[j]}`);
            j++;
        }
        
        console.log(`${indentacao}   ‚úÖ Mesclagem conclu√≠da: [${resultado.join(', ')}]`);
        return resultado;
    }
    
    /**
     * An√°lise de complexidade do Merge Sort
     */
    static analisarComplexidade(tamanhos: number[]): void {
        console.log("\nüìä AN√ÅLISE DE COMPLEXIDADE DO MERGE SORT");
        console.log("Comparando com outros algoritmos O(n¬≤)");
        console.log("============================================================");
        
        tamanhos.forEach(n => {
            const operacoesMerge = n * MathUtils.log2(n);
            const operacoesBubble = n * n;
            const melhoria = operacoesBubble / operacoesMerge;
            
            console.log(`\nüìè Array de tamanho ${n}:`);
            console.log(`   Merge Sort (n log n): ~${MathUtils.round(operacoesMerge)} opera√ß√µes`);
            console.log(`   Bubble Sort (n¬≤): ~${operacoesBubble} opera√ß√µes`);
            console.log(`   üöÄ Merge Sort √© ${melhoria.toFixed(1)}x mais r√°pido!`);
        });
    }
}

/**
 * EXERC√çCIO EXTRA 5: BUSCA BIN√ÅRIA INTERATIVA
 * Algoritmo O(log n) - muito eficiente para arrays ordenados!
 */
class BuscaBinariaInterativa {
    
    /**
     * Busca bin√°ria com explica√ß√£o detalhada
     * CONCEITO: "Chute inteligente" - sempre elimina metade das possibilidades
     * PR√â-REQUISITO: Array deve estar ordenado!
     */
    static buscar(array: number[], elemento: number): number {
        console.log(`üéØ BUSCA BIN√ÅRIA: Procurando ${elemento} em [${array.join(', ')}]`);
        console.log(`üí° CONCEITO: Eliminar metade das possibilidades a cada compara√ß√£o`);
        console.log(`‚ö†Ô∏è  PR√â-REQUISITO: Array deve estar ordenado!`);
        
        let inicio = 0;
        let fim = array.length - 1;
        let tentativas = 0;
        
        while (inicio <= fim) {
            tentativas++;
            const meio = Math.floor((inicio + fim) / 2);
            const valorMeio = array[meio];
            
            console.log(`\nüîç TENTATIVA ${tentativas}:`);
            console.log(`   Intervalo: posi√ß√µes ${inicio} a ${fim}`);
            console.log(`   Meio: posi√ß√£o ${meio}, valor ${valorMeio}`);
            console.log(`   Comparando: ${valorMeio} com ${elemento}`);
            
            if (valorMeio === elemento) {
                console.log(`   üéâ ENCONTRADO! Elemento ${elemento} est√° na posi√ß√£o ${meio}`);
                console.log(`   üìä Total de tentativas: ${tentativas}`);
                console.log(`   üöÄ Efici√™ncia: O(log n) = ${MathUtils.ceil(MathUtils.log2(array.length))} tentativas m√°ximas`);
                return meio;
            } else if (valorMeio < elemento) {
                console.log(`   ‚û°Ô∏è  ${valorMeio} < ${elemento}, procurando na metade direita`);
                inicio = meio + 1;
            } else {
                console.log(`   ‚¨ÖÔ∏è  ${valorMeio} > ${elemento}, procurando na metade esquerda`);
                fim = meio - 1;
            }
            
            console.log(`   Novo intervalo: posi√ß√µes ${inicio} a ${fim}`);
        }
        
        console.log(`\n‚ùå Elemento ${elemento} n√£o encontrado ap√≥s ${tentativas} tentativas`);
        return -1;
    }
    
    /**
     * Compara busca bin√°ria com busca linear
     */
    static compararComBuscaLinear(array: number[], elemento: number): void {
        console.log(`\n‚ö° COMPARA√á√ÉO: BUSCA BIN√ÅRIA vs BUSCA LINEAR`);
        console.log(`Array de ${array.length} elementos, buscando ${elemento}`);
        console.log("============================================================");
        
        // Busca Linear
        console.log(`\nüìç BUSCA LINEAR:`);
        let comparacoesLinear = 0;
        let indiceLinear = -1;
        
        for (let i = 0; i < array.length; i++) {
            comparacoesLinear++;
            if (array[i] === elemento) {
                indiceLinear = i;
                break;
            }
        }
        
        console.log(`   Compara√ß√µes: ${comparacoesLinear}`);
        console.log(`   Resultado: ${indiceLinear >= 0 ? `encontrado na posi√ß√£o ${indiceLinear}` : 'n√£o encontrado'}`);
        
        // Busca Bin√°ria
        console.log(`\nüéØ BUSCA BIN√ÅRIA:`);
        let inicio = 0, fim = array.length - 1, comparacoesBinaria = 0, indiceBinario = -1;
        
        while (inicio <= fim) {
            comparacoesBinaria++;
            const meio = Math.floor((inicio + fim) / 2);
            
            if (array[meio] === elemento) {
                indiceBinario = meio;
                break;
            } else if (array[meio] < elemento) {
                inicio = meio + 1;
            } else {
                fim = meio - 1;
            }
        }
        
        console.log(`   Compara√ß√µes: ${comparacoesBinaria}`);
        console.log(`   Resultado: ${indiceBinario >= 0 ? `encontrado na posi√ß√£o ${indiceBinario}` : 'n√£o encontrado'}`);
        
        // Resumo
        const eficiencia = comparacoesLinear / comparacoesBinaria;
        console.log(`\nüìä RESUMO:`);
        console.log(`   Busca bin√°ria √© ${eficiencia.toFixed(1)}x mais eficiente!`);
        console.log(`   Para array de ${array.length} elementos:`);
        console.log(`   - Linear: at√© ${array.length} compara√ß√µes`);
        console.log(`   - Bin√°ria: at√© ${MathUtils.ceil(MathUtils.log2(array.length))} compara√ß√µes`);
    }
}

/**
 * EXERC√çCIO EXTRA 6: QUICK SORT EXPLICADO
 * Algoritmo muito eficiente na pr√°tica - O(n log n) em m√©dia
 */
class QuickSortExplicado {
    
    /**
     * Quick Sort com visualiza√ß√£o completa
     * CONCEITO: Escolhe um "piv√¥" e organiza elementos menores √† esquerda, maiores √† direita
     */
    static ordenar(array: number[], inicio: number = 0, fim: number = array.length - 1, nivel: number = 0): number[] {
        const indentacao = MathUtils.repeat("  ", nivel);
        
        if (inicio < fim) {
            console.log(`${indentacao}üéØ QUICK SORT n√≠vel ${nivel}: array[${inicio}..${fim}] = [${array.slice(inicio, fim + 1).join(', ')}]`);
            
            // PARTICIONAMENTO: Organiza o array em torno do piv√¥
            const indicePivo = this.particionar(array, inicio, fim, nivel);
            
            console.log(`${indentacao}üìç Piv√¥ ${array[indicePivo]} na posi√ß√£o ${indicePivo}, array: [${array.join(', ')}]`);
            
            // RECURS√ÉO: Ordena as duas partes
            console.log(`${indentacao}‚¨ÖÔ∏è  Ordenando parte esquerda: [${array.slice(inicio, indicePivo).join(', ')}]`);
            this.ordenar(array, inicio, indicePivo - 1, nivel + 1);
            
            console.log(`${indentacao}‚û°Ô∏è  Ordenando parte direita: [${array.slice(indicePivo + 1, fim + 1).join(', ')}]`);
            this.ordenar(array, indicePivo + 1, fim, nivel + 1);
            
            console.log(`${indentacao}‚úÖ Conclu√≠do n√≠vel ${nivel}: [${array.slice(inicio, fim + 1).join(', ')}]`);
        }
        
        return array;
    }
    
    /**
     * Particionamento - a parte mais importante do Quick Sort
     * Organiza elementos menores que o piv√¥ √† esquerda, maiores √† direita
     */
    private static particionar(array: number[], inicio: number, fim: number, nivel: number): number {
        const indentacao = MathUtils.repeat("  ", nivel);
        const pivo = array[fim]; // Escolhemos o √∫ltimo elemento como piv√¥
        
        console.log(`${indentacao}  üé≤ Piv√¥ escolhido: ${pivo} (posi√ß√£o ${fim})`);
        
        let i = inicio - 1; // √çndice do menor elemento
        
        for (let j = inicio; j < fim; j++) {
            console.log(`${indentacao}  üîç Comparando ${array[j]} com piv√¥ ${pivo}`);
            
            // Se elemento atual √© menor ou igual ao piv√¥
            if (array[j] <= pivo) {
                i++;
                [array[i], array[j]] = [array[j], array[i]]; // Troca
                console.log(`${indentacao}    ‚ÜîÔ∏è ${array[j]} ‚â§ ${pivo}, trocando posi√ß√µes ${i} e ${j}: [${array.join(', ')}]`);
            } else {
                console.log(`${indentacao}    ‚û°Ô∏è ${array[j]} > ${pivo}, mantendo √† direita`);
            }
        }
        
        // Coloca o piv√¥ na posi√ß√£o correta
        [array[i + 1], array[fim]] = [array[fim], array[i + 1]];
        console.log(`${indentacao}  üéØ Colocando piv√¥ ${pivo} na posi√ß√£o correta ${i + 1}: [${array.join(', ')}]`);
        
        return i + 1; // Retorna a posi√ß√£o do piv√¥
    }
    
    /**
     * Demonstra diferentes estrat√©gias de escolha de piv√¥
     */
    static demonstrarEstrategiasPivo(): void {
        console.log("\nüé≤ ESTRAT√âGIAS DE ESCOLHA DE PIV√î NO QUICK SORT");
        console.log("============================================================");
        
        const arrayTeste = [3, 6, 8, 10, 1, 2, 1];
        
        console.log(`Array teste: [${arrayTeste.join(', ')}]`);
        console.log("\nüìã DIFERENTES ESTRAT√âGIAS:");
        console.log("1. üéØ √öltimo elemento (mais comum)");
        console.log("2. üéØ Primeiro elemento");
        console.log("3. üéØ Elemento do meio");
        console.log("4. üéØ Mediana de tr√™s (primeiro, meio, √∫ltimo)");
        console.log("5. üéØ Elemento aleat√≥rio");
        
        console.log("\nüí° DICAS:");
        console.log("‚Ä¢ Piv√¥ ruim = O(n¬≤) no pior caso");
        console.log("‚Ä¢ Piv√¥ bom = O(n log n) em m√©dia");
        console.log("‚Ä¢ Array j√° ordenado √© pior caso para piv√¥ fixo");
        console.log("‚Ä¢ Mediana de tr√™s √© uma boa estrat√©gia pr√°tica");
    }
}

// Execu√ß√£o dos exerc√≠cios intermedi√°rios
console.log("üü° EXERC√çCIOS EXTRAS - N√çVEL INTERMEDI√ÅRIO");
console.log("============================================================");

/**
 * EXERC√çCIO EXTRA 7: SEGUNDO MAIOR VALOR
 * Encontre o segundo maior valor em um array (O(n)).
 * Exemplo: [10, 5, 8, 12, 7] => 10
 */
function findSecondLargest(array: number[]): number | null {
    let max = -Infinity, second = -Infinity;
    for (let n of array) {
        if (n > max) {
            second = max;
            max = n;
        } else if (n > second && n < max) {
            second = n;
        }
    }
    return second === -Infinity ? null : second;
}
console.log("\nüü° EXERC√çCIO EXTRA 7: SEGUNDO MAIOR VALOR");
console.log(`findSecondLargest([10,5,8,12,7]) = ${findSecondLargest([10,5,8,12,7])}`);
console.log(`findSecondLargest([1,2,3,4]) = ${findSecondLargest([1,2,3,4])}`);

/**
 * EXERC√çCIO EXTRA 8: ELEMENTO MAJORIT√ÅRIO
 * Encontre o elemento que aparece mais da metade das vezes (Boyer-Moore).
 * Exemplo: [3,3,4,2,3,3,2,3,3] => 3
 */
function findMajorityElement(array: number[]): number | null {
    let count = 0, candidate = null;
    for (let n of array) {
        if (count === 0) candidate = n;
        count += (n === candidate) ? 1 : -1;
    }
    // Verifica se realmente √© majorit√°rio
    let ocorrencias = 0;
    for (let n of array) if (n === candidate) ocorrencias++;
    return ocorrencias > array.length / 2 ? candidate : null;
}
console.log("\nüü° EXERC√çCIO EXTRA 8: ELEMENTO MAJORIT√ÅRIO");
console.log(`findMajorityElement([3,3,4,2,3,3,2,3,3]) = ${findMajorityElement([3,3,4,2,3,3,2,3,3])}`);
console.log(`findMajorityElement([1,2,3,4]) = ${findMajorityElement([1,2,3,4])}`);
console.log("\nüìö EXERC√çCIO 4: MERGE SORT EDUCATIVO\n");

console.log("üî• DEMONSTRA√á√ÉO DO MERGE SORT:");
const arrayMerge = [38, 27, 43, 3, 9, 82, 10];
console.log(`Array inicial: [${arrayMerge.join(', ')}]\n`);

const resultadoMerge = MergeSortEducativo.ordenar([...arrayMerge]);
console.log(`\nüéâ RESULTADO FINAL: [${resultadoMerge.join(', ')}]`);

MergeSortEducativo.analisarComplexidade([10, 100, 1000, 10000]);

console.log("\n============================================================");
console.log("üìö EXERC√çCIO 5: BUSCA BIN√ÅRIA INTERATIVA\n");

const arrayBinariaDemo = [2, 5, 8, 12, 16, 23, 38, 45, 67, 78, 88, 99];
console.log("üîç DEMONSTRA√á√ÉO DA BUSCA BIN√ÅRIA:");
BuscaBinariaInterativa.buscar(arrayBinariaDemo, 23);

BuscaBinariaInterativa.compararComBuscaLinear(arrayBinariaDemo, 67);

console.log("\n============================================================");
console.log("üìö EXERC√çCIO 6: QUICK SORT EXPLICADO\n");

const arrayQuick = [10, 7, 8, 9, 1, 5];
console.log("‚ö° DEMONSTRA√á√ÉO DO QUICK SORT:");
console.log(`Array inicial: [${arrayQuick.join(', ')}]\n`);

const resultadoQuick = QuickSortExplicado.ordenar([...arrayQuick]);
console.log(`\nüéâ RESULTADO FINAL: [${resultadoQuick.join(', ')}]`);

QuickSortExplicado.demonstrarEstrategiasPivo();
